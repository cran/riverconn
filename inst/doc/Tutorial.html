<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>riverconn vignette</title>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.6.0/build/styles/github.min.css">
<script src="https://cdn.jsdelivr.net/combine/gh/highlightjs/cdn-release@11.6.0/build/highlight.min.js,npm/@xiee/utils/js/load-highlight.js" async></script>

<!-- MathJax scripts -->
<script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML" async>
</script>

<style type="text/css">
body, td {
  font-family: sans-serif;
  background-color: white;
  font-size: 13px;
}
body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
}
tt, code, pre {
  font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}
a:visited { color: #80007f; }
pre, img { max-width: 100%; }
code {
  font-size: 92%;
  border: 1px solid #ccc;
}
code[class] { background-color: #F8F8F8; }
code.language-undefined { background-color: inherit; }
table {
  margin: auto;
  border-top: 1px solid #666;
  border-bottom: 1px solid #666;
}
table thead th { border-bottom: 1px solid #ddd; }
th, td { padding: 5px; }
thead, tfoot, tr:nth-child(even) { background: #eee; }
blockquote {
  color:#666;
  margin:0;
  padding-left: 1em;
  border-left: 0.5em #eee solid;
}
hr { border: 1px #ddd dashed; }

@media print {
  * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
  }
  body {
    font-size: 12pt;
    max-width: 100%;
  }
  a, a:visited { text-decoration: underline; }
  hr {
    visibility: hidden;
    page-break-before: always;
  }
  pre, blockquote {
    padding-right: 1em;
    page-break-inside: avoid;
  }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style>



</head>

<body>
<h2>Indices to assess riverscape connectivity</h2>
<p>The riverconn package is used to calculate indices for river network connectivity. For a review of the indices, see <a href="https://doi.org/10.1088/1748-9326/abcb37">Jumani et al., 2021</a>, while for a list of the functionalities of the package and its architecture, see <a href="https://doi.org/10.1016/j.envsoft.2022.105470">Baldan et al., 2022</a>.</p>
<p>If you use this package, cite it as: <a href="https://doi.org/10.1016/j.envsoft.2022.105470">https://doi.org/10.1016/j.envsoft.2022.105470</a>.</p>
<p>For a tutorial on how to generate graphs representing rivers from “real world” data see: <a href="https://damianobaldan.github.io/riverconn_tutorial/">https://damianobaldan.github.io/riverconn_tutorial/</a></p>
<h3>The river network as a graph</h3>
<p>This package implements algorithms to compute commonly used indices to assess river networks connectivity All those indices assume a conceptualization of the river networks as a graph \(L = (E,V)\), where vertices (nodes) \(V\) represent single reaches, and edges (links) \(E\) represent either confluences or longitudinal barriers.</p>
<p>For example, the graphs below represents a river with ten reaches. The graph on the left is directed, i.e. edges are defined for ordered pair of vertices. The graph on the right is undirected, as the order of vertices for the definition of edges is unimportant. Both graph have a ‘tree-like’ structure, since no loops exist (acyclic graphs): this structure can be used to describe a river system. In both examples, both barriers and confluences are present. The edges between nodes 1 and 2 and 3 and 2 are confluences. The edge between node 2 and 4 is a barrier.</p>
<p>![plot of chunk graph example](figure/graph example-1.png)</p>
<h3>Generalized riverscape connectivity index</h3>
<p>river networks-level connectivity can be expressed in terms of coincidence probability (Pascual-Hortal and Saura, 2006), i.e. the probability that two random points in a river network are connected. Once the dispersal probability \(I_{ij}\) is defined for each couple of \(i,j\) nodes in the graph, generalized connectivity indices for catchment and reach scales can be calculated.</p>
<h5>Catchment Connectvity index</h5>
<p>The catchment-scale connectivity index (CCI) is calculated as:</p>
<p>$$
\ CCI = \sum_{i = 1}^{n} \sum_{j = 1}^{n} I_{ij} \frac{w_i w_j}{W^2}
$$
Where \(w_i\) and \(w_j\) are some node-level attributes (weights), and \(W\) is the sum of sum of the nodes weights for the whole river networks.</p>
<h4>Reach Connectivity Index</h4>
<p>The reach-scale connectivity index (RCI) is calculated by limiting the summation to all the connections to the single node \(i\).
$$
\ RCI_i = \sum_{j = 1}^{n} I_{ij} \frac{w_j}{W}
$$</p>
<h4>Node weights</h4>
<p>Nodes weights can be arbitrarily chosen. Common features used are the reach length ($l_i$), area($A_i$), or volume($V_i$). Alternatively, the habitat suitability index (HSI) can be used, defined as the ratio of length/area that is suitable for a specific organism.
$$
\ HSI_i = \frac{{l}<em>{i,suitable}}{l_i} \mbox{  ;         } HSI_i = \frac{{A}</em>{i,suitable}}{A_i}
$$
Here \({l}_{i,suitable}\) and \({A}_{i,suitable}\) are the fractions of length/area of reach \(i\) that are suitable, and are usually refferred to as weighted suitable length or weighted suitable area.</p>
<h3>Dispersal probability</h3>
<p>The dispersal probability depends on several factors: the presence of barriers between nodes \(i\) and \(j\) , the presence of suitable habitats in nodes \(i\) and \(j\) and alongside the connection, and the distance between \(i\) and \(j\). The dispersal probability \(I_{ij}\) is thus determined by several contributions. Those contributions are multiplied:</p>
<p>$$
\ I_{ij} = c_{ij}B_{ij}
$$
where \(c_{ij}\) accounts for the structural connectivity, i.e. it depends exclusively on the presence of barriers between nodes \(i\) and \(j\), and  \(B_{ij}\) accounts for the functional connectivity, i.e. it depends exclusively on the distance and the organisms movement/dispersal abilities.</p>
<h5>Structural connectivity</h5>
<p>The structural connectivity depends on the presence of barriers between nodes \(i\) and \(j\), and can be expressed as a function of the types of barriers present in the path expressed as a sequence of passability values. The passability \(p_m\) for the \(m\)-th barrier is defined as the probability that the reaches immediately upstream and downstream the barrier \(m\) are connected.</p>
<p>If the flow directionality is not relevant (i.e. the river graph can be conceptualized as undirected),</p>
<p>$$
\ c_{ij} = \prod_{m = 1}^{k} p_m^u p_m^d
$$
Where the product extends over the \(k\) nodes that are part of the path connecting reaches \(i\) and \(j\), \(p_m^u\) is the upsstream passability of the \(m\)-th barrier and \(p_m^u\) is the upstream passability of the \(m\)-th barrier. This definition based solely on products yields a symmetric coincidence probability (i.e. \(c_{ij} = c_{ji}\)).</p>
<p>A directional version of \(c_{ij}\) can be defined as:
$$
\ c_{ij} = \prod_{m = 1}^{k} p_m^{eq}
$$
$$
p_m^{eq} = \begin{cases}
p_m^u &amp; \mbox{if barrier m is encountered moving upstream in the path from i to j } \
p_m^d &amp; \mbox{if barrier m is encountered moving downstream in the path from i to j }
\end{cases}
$$
If \(i\) and \(j\) are located in different sub-catchments, the path from i to j will be moving downstream in some sections and upstream in some other secions: this \(p_m^{eq}\) definition ensures the retained passability value is consistent with the directionality of the path from \(i\) to \(j\) (i.e. \(c_{ij} \ne c_{ji}\))</p>
<h5>Functional connectivity</h5>
<p>Functional connectivity can be calculated as a function of the distance between reaches. An exponential dispersal kernel can be used:</p>
<p>$$
\ B_{ij} = PD^{d_{ij}}
$$
where \(PD\) is in the \((0,1)\) interval (smaller values mean more restricted movement), and \(d_{ij}\) is the distance between reaches \(i\) and \(j\). Alternatively, a threshold based probability can be used:
$$
\ B_{ij} = \begin{cases}
0 &amp; \mbox{when } d_{ij}&gt;d_{tr}  \
1 &amp; \mbox{when } d_{ij}&lt;=d_{tr}<br />
\end{cases}
$$
Both definitions can be easily adapted to asymmetric dispersal by defining \(PD_{d}\), \(PD_{u}\), \(d_{tr,u}\), and \(d_{tr,d}\), and calculating \(B_{ij} = B_{ij}^u B_{ij}^d\) where \(B_{ij}^u\) and \(B_{ij}^d\) are the index \(B_{ij}\) contribution calculated for the ‘downstream moving’ and ‘upstream moving’ sections in the path from  reach \(i\) to \(j\).</p>
<p>The distance \(d_{ij}\) can be either the geometric distance, or any other measure of effective distance (e.g. \(d_{ij} / (1-{HSI}_{ij})\) provides an estimate of effective distance that depends on the habitat suitability index between reaches \(i\) and \(j\))</p>
<h3>Prioritization of barriers</h3>
<p>All the defined connectivity index can be used to prioritize barriers removal with a ‘leave-one-out’ approach. For each barrier, the index \(dCCI\) can be defined as:
$$
\ dCCI_{m} = 100 \frac{CCI - CCI_{m, removed}}{GCI}
$$
where \(CCI\) is the generalized connectivity index calculated for the original river networks with all the barriers implemented, and CCI_{m, removed} is the index recalculated when barrier \(m\) is removed or its passability is changed (an equivalent for the reach scale, \(dRCI_{i}\), can be defined similarly) .</p>
<p>An alternative version of the index for prioritizing barriers can be calculated as the decrease in river networks connectivity after a single barrier is implemented, with a ‘add-one’ approach.</p>
<h3>Time-dependent connectivity</h3>
<p>When barriers metadata on the year of construction and the year of implementation of mitigation measures are available, a time trajectory of GCI can be computed (e.g. Segurado et al., 2013).</p>
<h2>Preliminary steps</h2>
<pre><code class="language-r">library(igraph)
library(dplyr)
library(tidyr)
library(ggnetwork)
library(viridis)
library(riverconn)
library(doParallel)
</code></pre>
<h2>Preprocessing of input data</h2>
<p>This package relies heavily on the functionalities of the <code>igraph</code> package. The <code>igraph</code> package implements routines for simple graphs and network analysis. It can handle large graphs very well and provides functions for generating random and regular graphs, graph visualization, centrality methods and much more. The package allows for easy construction of <code>igraph</code> objects based on edges and vertices lists or adjacency matrices. The book ‘Statistical Analysis of Network Data with R’ by Kolaczyk and Csardi (2014) offers a comprehensive tutorial on the possibilities offered by the ‘igraph’ package.</p>
<p>A more comprehensive tutorial, including a real-world case study can be found here: <a href="https://damianobaldan.github.io/riverconn_tutorial/">https://damianobaldan.github.io/riverconn_tutorial/</a></p>
<h3>Input class ‘igraph’ object</h3>
<p>All the functions implemented in this package use as main input an object of class <code>igraph</code>. There are different ways an object of class <code>igraph</code> can be created. A symbolic sequence of edges can be used with the function <code>graph_from_literal</code> for small, toy graphs.</p>
<pre><code class="language-r">g &lt;- graph_from_literal(1-+2, 2-+5, 3-+4, 4-+5, 6-+7, 7-+10, 8-+9, 9-+10, 
                        5-+11, 11-+12, 10-+13, 13-+12, 12-+14, 14-+15, 15-+16)
g
## IGRAPH b438b43 DN-- 16 15 -- 
## + attr: name (v/c)
## + edges from b438b43 (vertex names):
##  [1] 1 -&gt;2  2 -&gt;5  5 -&gt;11 3 -&gt;4  4 -&gt;5  6 -&gt;7  7 -&gt;10 10-&gt;13 8 -&gt;9  9 -&gt;10
## [11] 11-&gt;12 12-&gt;14 13-&gt;12 14-&gt;15 15-&gt;16
</code></pre>
<p>Note that when a graph is defined this way, edged and vertices attributes are not defined.</p>
<pre><code class="language-r"># Edges
E(g)
## + 15/15 edges from b438b43 (vertex names):
##  [1] 1 -&gt;2  2 -&gt;5  5 -&gt;11 3 -&gt;4  4 -&gt;5  6 -&gt;7  7 -&gt;10 10-&gt;13 8 -&gt;9  9 -&gt;10
## [11] 11-&gt;12 12-&gt;14 13-&gt;12 14-&gt;15 15-&gt;16

# vertices
V(g)
## + 16/16 vertices, named, from b438b43:
##  [1] 1  2  5  3  4  6  7  10 8  9  11 12 13 14 15 16
</code></pre>
<p>The graph can be converted to data frame with the function <code>as_data_frame</code>, specifying if edges or vertices are to be exported. Accordingly, the function <code>graph_from_data_frame</code> can be used to create an igraph object from a data frame.</p>
<pre><code class="language-r">igraph::as_data_frame(g, what = &quot;edges&quot;)
##    from to
## 1     1  2
## 2     2  5
## 3     5 11
## 4     3  4
## 5     4  5
## 6     6  7
## 7     7 10
## 8    10 13
## 9     8  9
## 10    9 10
## 11   11 12
## 12   12 14
## 13   13 12
## 14   14 15
## 15   15 16

igraph::as_data_frame(g, what = &quot;vertices&quot;)
##    name
## 1     1
## 2     2
## 5     5
## 3     3
## 4     4
## 6     6
## 7     7
## 10   10
## 8     8
## 9     9
## 11   11
## 12   12
## 13   13
## 14   14
## 15   15
## 16   16
</code></pre>
<p>Finally, an igraph object can be exported to and generated from adjacency matrices using the functions <code>as_adjacency_matrix</code> and <code>graph_from_adjacency_matrix</code>, specifying if edges or vertices are to be exported.</p>
<pre><code class="language-r">igraph::as_adjacency_matrix(g)
## 16 x 16 sparse Matrix of class &quot;dgCMatrix&quot;
##                                   
## 1  . 1 . . . . . . . . . . . . . .
## 2  . . 1 . . . . . . . . . . . . .
## 5  . . . . . . . . . . 1 . . . . .
## 3  . . . . 1 . . . . . . . . . . .
## 4  . . 1 . . . . . . . . . . . . .
## 6  . . . . . . 1 . . . . . . . . .
## 7  . . . . . . . 1 . . . . . . . .
## 10 . . . . . . . . . . . . 1 . . .
## 8  . . . . . . . . . 1 . . . . . .
## 9  . . . . . . . 1 . . . . . . . .
## 11 . . . . . . . . . . . 1 . . . .
## 12 . . . . . . . . . . . . . 1 . .
## 13 . . . . . . . . . . . 1 . . . .
## 14 . . . . . . . . . . . . . . 1 .
## 15 . . . . . . . . . . . . . . . 1
## 16 . . . . . . . . . . . . . . . .
</code></pre>
<h3>Decorating the class ‘igraph’ object</h3>
<p>Once the structure of the network is defined, the graph can be decorated with edges and vertices attributes. Attributes can be either added directly to the graph or joined to the edges and vertices data frame. edges and vertices attributes are saved as vectors, so common, data.frame-like operations are possible.</p>
<p>Here we add the dam information as edge attribute, including the field ‘id_dam’, and the reach information data as vertices attributes, including the length and the corresponding habitat suitability index.</p>
<pre><code class="language-r"># Decorate edges 
E(g)$id_dam &lt;- c(&quot;1&quot;, NA, &quot;2&quot;, &quot;3&quot;, NA, &quot;4&quot;, NA, &quot;5&quot;, &quot;6&quot;, NA,  NA, NA, NA, &quot;7&quot;, NA)
E(g)$type &lt;- ifelse(is.na(E(g)$id_dam), &quot;joint&quot;, &quot;dam&quot;)
E(g)
## + 15/15 edges from b438b43 (vertex names):
##  [1] 1 -&gt;2  2 -&gt;5  5 -&gt;11 3 -&gt;4  4 -&gt;5  6 -&gt;7  7 -&gt;10 10-&gt;13 8 -&gt;9  9 -&gt;10
## [11] 11-&gt;12 12-&gt;14 13-&gt;12 14-&gt;15 15-&gt;16

# Decorate vertices
V(g)$length &lt;- c(1, 1, 2, 3, 4, 1, 5, 1, 7, 7, 3, 2, 4, 5, 6, 9)
V(g)$HSI &lt;- c(0.2, 0.1, 0.3, 0.4, 0.5, 0.5, 0.5, 0.6, 0.7, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8)
V(g)$Id &lt;- V(g)$name
V(g)
## + 16/16 vertices, named, from b438b43:
##  [1] 1  2  5  3  4  6  7  10 8  9  11 12 13 14 15 16
</code></pre>
<h3>Visualizing the ‘igraph’ object</h3>
<p>The <code>ggnetwork</code> library can be used to plot a igraph object with <code>tidyverse</code>-friendly functions. The function <code>ggnetwork</code> is used to fortify <code>igraph</code> objects with a specified layout. Here the tree layout is used, but for real river networks the coordinates of the reaches centroids can be used.</p>
<pre><code class="language-r">gg0 &lt;- ggnetwork(g, layout =  layout_as_tree(g %&gt;% as.undirected, root = 16), scale = FALSE)

ggplot(gg0, aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_nodes(alpha = 0.3) +
  geom_edges(alpha = 0.5, 
             arrow = arrow(length = unit(10, &quot;pt&quot;), type = &quot;closed&quot;), 
             aes(color = type)) + 
  scale_color_viridis(discrete = TRUE)+
  geom_nodetext(aes(label = name), fontface = &quot;bold&quot;) +
  theme_blank()
</code></pre>
<p>![plot of chunk plot igraph](figure/plot igraph-1.png)</p>
<p>This function can be used to display all the graph attributes.</p>
<pre><code class="language-r">ggplot(gg0, aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_edges(alpha = 0.5, 
             arrow = arrow(length = unit(10, &quot;pt&quot;), type = &quot;open&quot;)) +
  geom_nodes(aes(size = length, color = HSI)) +
  scale_color_viridis()+
  theme_blank()
</code></pre>
<p>![plot of chunk plot igraph 2](figure/plot igraph 2-1.png)</p>
<h3>Assigning network directionality</h3>
<p>The <code>riverconn</code> package implements the function <code>set_graph_directionality</code> that allows to assign the directionality of the graph once an outlet is defined.</p>
<pre><code class="language-r">oldpar &lt;- par(mfrow = c(1,1))
par(mfrow=c(1,3))
g1 &lt;- set_graph_directionality(g, field_name = &quot;Id&quot;, outlet_name = &quot;16&quot;)
g2 &lt;- set_graph_directionality(g, field_name = &quot;Id&quot;, outlet_name = &quot;5&quot;)
plot(as.undirected(g), layout = layout_as_tree(as.undirected(g), root = 8, flip.y = FALSE))
plot(g1, layout = layout_as_tree(as.undirected(g1), root = 16, flip.y = FALSE))
plot(g2, layout = layout_as_tree(as.undirected(g2), root = 5, flip.y = FALSE))
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk direction" /></p>
<pre><code class="language-r">par(oldpar)
</code></pre>
<h2>Indices calculation</h2>
<p>The function <code>index_calcualtion</code> is used to calculate all the nuances of the CCI and RCI</p>
<p>Before calculation, the information on the barriers passability are needed.</p>
<pre><code class="language-r"># Check edged and nodes attributes, add pass_u and pass_d fields
g_v_df &lt;- igraph::as_data_frame(g, what = &quot;vertices&quot;)
g_v_df
##    name length HSI Id
## 1     1      1 0.2  1
## 2     2      1 0.1  2
## 5     5      2 0.3  5
## 3     3      3 0.4  3
## 4     4      4 0.5  4
## 6     6      1 0.5  6
## 7     7      5 0.5  7
## 10   10      1 0.6 10
## 8     8      7 0.7  8
## 9     9      7 0.8  9
## 11   11      3 0.8 11
## 12   12      2 0.8 12
## 13   13      4 0.8 13
## 14   14      5 0.8 14
## 15   15      6 0.8 15
## 16   16      9 0.8 16
g_e_df &lt;- igraph::as_data_frame(g, what = &quot;edges&quot;) %&gt;%
  mutate(pass_u = ifelse(!is.na(id_dam),0.1,NA),
         pass_d = ifelse(!is.na(id_dam),0.7,NA))
g_e_df
##    from to id_dam  type pass_u pass_d
## 1     1  2      1   dam    0.1    0.7
## 2     2  5   &lt;NA&gt; joint     NA     NA
## 3     5 11      2   dam    0.1    0.7
## 4     3  4      3   dam    0.1    0.7
## 5     4  5   &lt;NA&gt; joint     NA     NA
## 6     6  7      4   dam    0.1    0.7
## 7     7 10   &lt;NA&gt; joint     NA     NA
## 8    10 13      5   dam    0.1    0.7
## 9     8  9      6   dam    0.1    0.7
## 10    9 10   &lt;NA&gt; joint     NA     NA
## 11   11 12   &lt;NA&gt; joint     NA     NA
## 12   12 14   &lt;NA&gt; joint     NA     NA
## 13   13 12   &lt;NA&gt; joint     NA     NA
## 14   14 15      7   dam    0.1    0.7
## 15   15 16   &lt;NA&gt; joint     NA     NA

# Recreate graph
g &lt;- igraph::graph_from_data_frame(d = g_e_df, vertices = g_v_df)
g 
## IGRAPH b655fb5 DN-- 16 15 -- 
## + attr: name (v/c), length (v/n), HSI (v/n), Id (v/c), id_dam (e/c),
## | type (e/c), pass_u (e/n), pass_d (e/n)
## + edges from b655fb5 (vertex names):
##  [1] 1 -&gt;2  2 -&gt;5  5 -&gt;11 3 -&gt;4  4 -&gt;5  6 -&gt;7  7 -&gt;10 10-&gt;13 8 -&gt;9  9 -&gt;10
## [11] 11-&gt;12 12-&gt;14 13-&gt;12 14-&gt;15 15-&gt;16
</code></pre>
<p>Index with default settings.</p>
<pre><code class="language-r">index_calculation(g, param = 0.9)
##        num  den    index
## 1 553.8299 3721 0.148839
</code></pre>
<p>Index with default settings, only \(c_{ij}\) or \(B_{ij}\) contributions</p>
<pre><code class="language-r">index_calculation(g, B_ij_flag = FALSE)
##        num  den     index
## 1 791.8553 3721 0.2128071
index_calculation(g, param = 0.9, c_ij_flag = FALSE)
##       num  den     index
## 1 1200.63 3721 0.3226632
</code></pre>
<p>Index with default settings, only \(B_{ij}\) contributions with threshold on the distance</p>
<pre><code class="language-r">index_calculation(g, c_ij_flag = FALSE,
                  dir_distance_type = &quot;asymmetric&quot;, 
                  disp_type = &quot;threshold&quot;, param_u = 0, param_d = 5)
##   num  den     index
## 1 453 3721 0.1217415
index_calculation(g, c_ij_flag = FALSE,
                  dir_distance_type = &quot;asymmetric&quot;, 
                  disp_type = &quot;threshold&quot;, param_u = 5, param_d = 10)
##    num  den     index
## 1 1028 3721 0.2762698
index_calculation(g, c_ij_flag = FALSE,
                  dir_distance_type = &quot;symmetric&quot;, 
                  disp_type = &quot;threshold&quot;, param = 10)
##    num  den    index
## 1 1239 3721 0.332975
</code></pre>
<p>Index for reach, inbound connections used, only \(B_{ij}\) contributions with threshold on the distance</p>
<pre><code class="language-r">index_calculation(g, c_ij_flag = FALSE,
                  index_type = &quot;reach&quot;, index_mode = &quot;to&quot;,
                  dir_distance_type = &quot;asymmetric&quot;, 
                  disp_type = &quot;threshold&quot;, param_u = 0, param_d = 5)
##    name num den      index
## 1     1   7  61 0.11475410
## 2     2   6  61 0.09836066
## 5     5   7  61 0.11475410
## 3     3   7  61 0.11475410
## 4     4   6  61 0.09836066
## 6     6   6  61 0.09836066
## 7     7   6  61 0.09836066
## 10   10   7  61 0.11475410
## 8     8   7  61 0.11475410
## 9     9   7  61 0.11475410
## 11   11  10  61 0.16393443
## 12   12   7  61 0.11475410
## 13   13   6  61 0.09836066
## 14   14  11  61 0.18032787
## 15   15   6  61 0.09836066
## 16   16   9  61 0.14754098
index_calculation(g, c_ij_flag = FALSE,
                  dir_distance_type = &quot;asymmetric&quot;,
                  index_type = &quot;reach&quot;, index_mode = &quot;to&quot;,
                  disp_type = &quot;threshold&quot;, param_u = 5, param_d = 10)
##    name num den     index
## 1     1  23  61 0.3770492
## 2     2  23  61 0.3770492
## 5     5  23  61 0.3770492
## 3     3  14  61 0.2295082
## 4     4  21  61 0.3442623
## 6     6  11  61 0.1803279
## 7     7  18  61 0.2950820
## 10   10  22  61 0.3606557
## 8     8  14  61 0.2295082
## 9     9  17  61 0.2786885
## 11   11  25  61 0.4098361
## 12   12  23  61 0.3770492
## 13   13  17  61 0.2786885
## 14   14  16  61 0.2622951
## 15   15  20  61 0.3278689
## 16   16   9  61 0.1475410
index_calculation(g, c_ij_flag = FALSE,
                  index_type = &quot;reach&quot;, index_mode = &quot;to&quot;,
                  dir_distance_type = &quot;symmetric&quot;, 
                  disp_type = &quot;threshold&quot;, param = 10)
##    name num den     index
## 1     1  21  61 0.3442623
## 2     2  25  61 0.4098361
## 5     5  26  61 0.4262295
## 3     3  14  61 0.2295082
## 4     4  16  61 0.2622951
## 6     6  11  61 0.1803279
## 7     7  13  61 0.2131148
## 10   10  30  61 0.4918033
## 8     8  14  61 0.2295082
## 9     9  19  61 0.3114754
## 11   11  32  61 0.5245902
## 12   12  34  61 0.5573770
## 13   13  31  61 0.5081967
## 14   14  25  61 0.4098361
## 15   15  25  61 0.4098361
## 16   16  15  61 0.2459016
</code></pre>
<h2>Prioritization calculation and visualization</h2>
<p>The function <code>index_calcualtion</code> allows to calculate the CCI and RCI changes when barriers are removed. Metadata on which dams are to be removed and how the passability changes are to be provided in the ‘dams_metadata’ object. Parallel calculations can be activated.</p>
<pre><code class="language-r">dams_metadata &lt;- data.frame(&quot;id_dam&quot; =  c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;),
                            &quot;pass_u_updated&quot; = c(1, 1, 1, 1, 1, 1, 1),
                            &quot;pass_d_updated&quot; = c(1, 1, 1, 1, 1, 1, 1))
dams_metadata
##   id_dam pass_u_updated pass_d_updated
## 1      1              1              1
## 2      2              1              1
## 3      3              1              1
## 4      4              1              1
## 5      5              1              1
## 6      6              1              1
## 7      7              1              1

d_index_calculation(g,
                    barriers_metadata = dams_metadata,
                    id_barrier = &quot;id_dam&quot;,
                    parallel = FALSE, ncores = 3,
                    param_u = 10,  param_d = 10, param = 0.5,
                    index_type = &quot;full&quot;,
                    dir_distance_type = &quot;asymmetric&quot;,
                    disp_type = &quot;threshold&quot;)
##   id_dam      num  den     index  index_bl   d_index
## 1      1 759.0978 3721 0.2040037 0.1998951  2.055376
## 2      2 897.4074 3721 0.2411737 0.1998951 20.650131
## 3      3 784.4321 3721 0.2108122 0.1998951  5.461397
## 4      4 768.5105 3721 0.2065333 0.1998951  3.320849
## 5      5 911.6736 3721 0.2450077 0.1998951 22.568122
## 6      6 834.9497 3721 0.2243885 0.1998951 12.253134
## 7      7 855.4097 3721 0.2298871 0.1998951 15.003837
</code></pre>
<p>Calculated index can be joined with the original graph and plotted to check spatial patterns.</p>
<pre><code class="language-r">
d_index &lt;- d_index_calculation (g,
                                barriers_metadata = dams_metadata,
                                id_barrier = &quot;id_dam&quot;,
                                parallel = FALSE, ncores = 3,
                                param_u = 10,  param_d = 10,
                                index_type = &quot;full&quot;,
                                B_ij_flag = FALSE)

# Check edged and nodes attributes
g_v_df &lt;- igraph::as_data_frame(g, what = &quot;vertices&quot;)
g_v_df
##    name length HSI Id
## 1     1      1 0.2  1
## 2     2      1 0.1  2
## 5     5      2 0.3  5
## 3     3      3 0.4  3
## 4     4      4 0.5  4
## 6     6      1 0.5  6
## 7     7      5 0.5  7
## 10   10      1 0.6 10
## 8     8      7 0.7  8
## 9     9      7 0.8  9
## 11   11      3 0.8 11
## 12   12      2 0.8 12
## 13   13      4 0.8 13
## 14   14      5 0.8 14
## 15   15      6 0.8 15
## 16   16      9 0.8 16
g_e_df &lt;- igraph::as_data_frame(g, what = &quot;edges&quot;) %&gt;%
  left_join(d_index, by = &quot;id_dam&quot;)
g_e_df
##    from to id_dam  type pass_u pass_d       num  den     index  index_bl
## 1     1  2      1   dam    0.1    0.7  807.3490 3721 0.2169710 0.2128071
## 2     2  5   &lt;NA&gt; joint     NA     NA        NA   NA        NA        NA
## 3     5 11      2   dam    0.1    0.7 1008.4973 3721 0.2710286 0.2128071
## 4     3  4      3   dam    0.1    0.7  837.5552 3721 0.2250887 0.2128071
## 5     4  5   &lt;NA&gt; joint     NA     NA        NA   NA        NA        NA
## 6     6  7      4   dam    0.1    0.7  818.9726 3721 0.2200947 0.2128071
## 7     7 10   &lt;NA&gt; joint     NA     NA        NA   NA        NA        NA
## 8    10 13      5   dam    0.1    0.7 1184.2933 3721 0.3182729 0.2128071
## 9     8  9      6   dam    0.1    0.7  976.2077 3721 0.2623509 0.2128071
## 10    9 10   &lt;NA&gt; joint     NA     NA        NA   NA        NA        NA
## 11   11 12   &lt;NA&gt; joint     NA     NA        NA   NA        NA        NA
## 12   12 14   &lt;NA&gt; joint     NA     NA        NA   NA        NA        NA
## 13   13 12   &lt;NA&gt; joint     NA     NA        NA   NA        NA        NA
## 14   14 15      7   dam    0.1    0.7 1223.1558 3721 0.3287170 0.2128071
## 15   15 16   &lt;NA&gt; joint     NA     NA        NA   NA        NA        NA
##      d_index
## 1   1.956632
## 2         NA
## 3  27.358782
## 4   5.771242
## 5         NA
## 6   3.424522
## 7         NA
## 8  49.559308
## 9  23.281074
## 10        NA
## 11        NA
## 12        NA
## 13        NA
## 14 54.467087
## 15        NA

# Recreate graph
g &lt;- igraph::graph_from_data_frame(d = g_e_df, vertices = g_v_df)
g 
## IGRAPH b8b4f66 DN-- 16 15 -- 
## + attr: name (v/c), length (v/n), HSI (v/n), Id (v/c), id_dam (e/c),
## | type (e/c), pass_u (e/n), pass_d (e/n), num (e/n), den (e/n), index
## | (e/n), index_bl (e/n), d_index (e/n)
## + edges from b8b4f66 (vertex names):
##  [1] 1 -&gt;2  2 -&gt;5  5 -&gt;11 3 -&gt;4  4 -&gt;5  6 -&gt;7  7 -&gt;10 10-&gt;13 8 -&gt;9  9 -&gt;10
## [11] 11-&gt;12 12-&gt;14 13-&gt;12 14-&gt;15 15-&gt;16

# Fortify and plot graph
gg0 &lt;- ggnetwork(g, layout =  layout_as_tree(g %&gt;% as.undirected, root = 16), scale = FALSE)
ggplot(gg0, aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_edges(alpha = 0.5, size = 3,
             arrow = arrow(length = unit(10, &quot;pt&quot;), type = &quot;open&quot;), 
             aes(color = d_index)) +
  geom_nodes() +
  scale_color_viridis()+
  theme_blank()
</code></pre>
<p>![plot of chunk plot join](figure/plot join-1.png)</p>
<h2>References and key literature</h2>
<p>Belletti, Barbara, et al. “More than one million barriers fragment Europe’s rivers.” Nature 588.7838 (2020): 436-441.</p>
<p>Cote, D., Kehler, D. G., Bourne, C., &amp; Wiersma, Y. F. (2009). A new measure of longitudinal connectivity for stream networks. Landscape Ecology, 24(1), 101-113.</p>
<p>Kolaczyk, E. D., &amp; Csárdi, G. (2014). Statistical analysis of network data with R (Vol. 65). New York: Springer.</p>
<p>Jumani, S., Deitch, M. J., Kaplan, D., Anderson, E. P., Krishnaswamy, J., Lecours, V., &amp; Whiles, M. R. (2020). River fragmentation and flow alteration metrics: a review of methods and directions for future research. Environmental Research Letters.</p>


<script src="https://cdn.jsdelivr.net/combine/npm/@xiee/utils/js/center-img.min.js" async></script>
</body>

</html>
